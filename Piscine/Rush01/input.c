/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   input.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bena <bena@student.42seoul.kr>             +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2022/09/03 21:40:10 by bena              #+#    #+#             */
/*   Updated: 2022/09/04 21:40:21 by bena             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdlib.h>

// 입력받은 문자열을 1차원 int형 배열로 변환할 것입니다. ( char -> int )
int	*get_linear_data(char *input_string)
{
	int	*linear_data;
	int	i;

	// 크기가 n일때, 인풋값으로 4 x n 만큼의 값을 받습니다.
	// n은 1~9의 값이므로 n = 9 일때 총 36의 값을 받습니다.
	// 이때 linear_data 배열의 첫번째는 받은 값의 개수를 적으므로 최대 37만큼의 공간이 필요합니다.
	// ( sizeof(int) * 37 이상의 공간 필요 )
	//
	// 혹시라도 9 x 9 의 크기까지 받을 수 있도록 82 (9 x 9 + 1)를 할당하였으나,
	// 딱히 쓸일이 없어 37이면 충분하긴 합니다. (크게 문제 안됨)
	linear_data = malloc(sizeof(int) * 82);
	i = -1;
	//배열의 첫번째 위치에는 인풋값이 비정상일 경우 0을, 아닌경우 인풋값의 개수를 저장합니다.
	//우선은 처음에 1로 할당을 해두고, 오류가 있으면 이 값을 0으로 변경합니다.
	linear_data[0] = 1;
	while (input_string[++i])
	{
		//인풋값은 "1 2 2 1 1 2 2 1" 같은 형식으로 입력됩니다.
		//짝수 인덱스에는 숫자가, 홀수 인덱스에는 반드시 공백 문자가 위치합니다.
		//
		//짝수 인덱스인 경우 숫자값이 들어왔는지 비교합니다.
		if (i % 2 == 0)
		{
			//아스키 값 기준으로 숫자가 아닌 문자이면 오류로 판정합니다. (0번 위치에 0값을 넣음)
			if (input_string[i] < '1' || '9' < input_string[i])
				linear_data[0] = 0;
			//정상적인 숫자 값이 들어왔으면 문자를 숫자로 변환해서 넣습니다.
			linear_data[i / 2 + 1] = input_string[i] - '0';
			//인풋값에서 1, 2, 3, 4 ... 번째 문자의 인덱스는 각각 0, 2, 4, 6 ... 입니다.
			//따라서 입력받은 문자열의 인덱스를 단순히 2로 나눠주면 linear_data에 들어갈 위치의 인덱스가 나옵니다.
			//이때, 배열의 첫번째 공간에는 오류 코드(0) 혹은 인자의 개수를 저장할 것이므로 두번째 공간부터 저장합니다.
			//따라서 인덱스를 2로 나눈 i / 2에, 두번째 공간부터 저장할 것이므로 + 1을 한 인덱스에 넣습니다.
			//최종적으로 input_string[i]는 linear_data의 i / 2 + 1 인덱스에 저장됩니다.
		}
		//홀수 인덱스인경우 공백이여야 합니다.
		if (i % 2 == 1)
			//공백이 아닌경우 오류로 판정합니다 (0번 위치에 0 값을 넣음)
			if (input_string[i] != ' ')
				linear_data[0] = 0;
	}
	//반복문이 끝나면 i에는 문자열 끝의 널 문자의 인덱스가 저장되어 있습니다.

	//위의 문자열을 정수 배열로 변환해 저장하는해서 단 한번의 오류라도 발생했다면,
	//첫번째 공간에 0 값이 들어있을 것입니다. (처음에 1을 넣어뒀으므로, 오류가 발생하면 0, 오류가 없었다면 1)
	//0이 들어있는 경우 오류로 인식하고 바로 리턴합니다.
	//
	//반환된 linear_data 함수 배열은 get_data함수의 인자값으로 들어가게 되는데
	//linear_data의 첫번째 공간에 0이 있으면 get_data함수는 [4]에 널 포인터가 있는 배열을 반환합니다.
	//그리고 get_data함수에서 반환한 배열은 main 함수로 전달됩니다.
	//이때 main 함수는 반환된 배열에서 [4]위치에 널 포인터가 있으면 오류로 판정합니다.
	if (linear_data[0] == 0)
		return (linear_data);

	//인풋값이 제대로 입력되어 오류가 없었다면 linear_data의 첫번째 값이 1이 입력되어 있으며
	//바로 위에 오류를 검사하는 if문이 실행되지 않고 그대로 통과됩니다.
	//이제 1이라는 값은 더이상 쓸모가 없으므로, linear_data[0]공간에 입력된 숫자의 개수를 넣습니다.
	linear_data[0] = i / 2 + 1;
	//입력받은 문자열에서, 첫번째 숫자의 인덱스는 0, 두번째 숫자의 인덱스는 2, 세번째 숫자의 인덱스는 4...
	//위와 같이 등차수열로 증가하게 됩니다.
	//
	//n번째 문자열의 인덱스 k는 2n - 2가 됩니다.
	//
	//이때 i에는 널 문자의 인덱스를 가리키므로, 마지막 n번째 문자의 인덱스 k는 i - 1이 됩니다.
	//따라서 k = i - 1 = 2n - 2 이므로.
	//2n = i + 3 입니다.
	//
	//양변을 2로 나누면
	//n = i / 2 + 1 + 1/2
	//
	//이때 정수 연산에서 1/2은 그냥 버려지므로 최종적으로 n = i / 2 + 1이 됩니다.
	//
	//이 규칙에 의하여 linear_data[0]에 i / 2 + 1을 넣으면 입력받은 숫자의 개수가 저장됩니다.

	return (linear_data);
}

int	**get_data(int *linear_data)
{
	int	**data;
	int	n;
	int	i;
	int	j;

	//위의 get_linear_data 함수로부터 받은 1차원 배열을 4 x n 크기의 배열로 재정렬 합니다.
	//
	//int 포인터를 5개 할당할 배열을 선언합니다. 
	//(0, 1, 2, 3 에는 상 하 좌 우 인풋값 배열이 각각 들어가고 5번째에는 오류 코드(널 포인터) or n값이 저장될 것입니다.)
	data = malloc(sizeof(int *) * 5);

	//인풋 값은 n x n 배열의 크기 n의 4배만큼 입력됩니다 (상하좌우 하나씩)
	//따라서 linear_data 맨 앞에 저장된 입력된 숫자 개수를 4로 나누면 n이 나옵니다.
	n = linear_data[0] / 4;

	//이제 linear_data에 들어있는 값이 제대로 되어있는지 검사할 것입니다.
	//
	//우선 get_linear_data 함수에서 오류가 있는 경우 linear_data[0] 위치에 0을 저장 후 반환합니다.
	//따라서 0인경우는 오류입니다.
	//그리고 입력된 숫자가 4의배수가 아니면 오류입니다.
	//n이 9보다 크면 오류입니다.
	//
	//셋중 하나라도 조건을 만족하면 오류로 판정합니다.
	//오류로 판정되면 배열의 [4] 위치에 널 포인터를 넣고 반환합니다.
	//[4]위치에 널 포인터가 있으면 반환값을 받은 main 함수에서 오류를 출력하고 즉시 종료합니다.
	//
	//n * 4 != linear_data[0] 조건은 인풋값 숫자 개수가 4의 배수인지를 확인하는 조건입니다.
	//n에는 linear_data[0]를 4로 나눈 값이 저장되어 있는데, n에 다시 4를 곱해서 linear_data[0]과 비교합니다.
	//
	//입력받은 값의 개수가 4의 배수라면 n * 4는 linear_data[0]과 같은 값이 나타납니다.
	//
	//예를들어 12의 경우, 4를 나누면 3이되고 다시 4를 곱하면 12가 되지만,
	//13같이 4의 배수가 아닌 경우, 4를 나누면 3이되고 다시 4를 곱하면 12가 되어 원래 값인 13이 되지 않으므로
	//4의 배수가 아닙니다.
	if (linear_data[0] == 0 || n * 4 != linear_data[0] || n > 9)
	{
		data[4] = 0;
		return (data);
	}
	//위 조건문으로부터 오류가 없다면 이제 1차원 배열 linear_data를 2차원 배열로 재정렬 합니다.
	i = -1;
	while (++i < 4)
		//각각 상, 하, 좌, 우의 인풋값을 넣을 4개의 배열을 메모리 할당합니다. [0~3]까지. [4]는 n 저장 및 오류코드용
		data[i] = malloc(sizeof(int) * n);

	//linear_data의 1 ~ n 까지 인덱스 값을 data[0][0] ~ data[0][n]에 넣습니다.
	//linear_data의 n+1 ~ 2n 까지 인덱스 값을 data[1][0] ~ data[1][n]에 넣습니다.
	//linear_data의 2n+1 ~ 3n 까지 인덱스 값을 data[2][0] ~ data[2][n]에 넣습니다.
	//linear_data의 3n+1 ~ 4n 까지 인덱스 값을 data[3][0] ~ data[3][n]에 넣습니다.
	i = -1;
	while (++i < 4 * n)
		data[i / n][i % n] = linear_data[i + 1];
	//i / n 과 i % n은 n진법 변환을 생각하면 됩니다.
	//예를들어 n이 4일때 총 16개의 문자를 받았다고 치면, 각각의 문자의 인덱스는
	//1, 2, 3, 4, 5, 6, 7, 8, 9 ,10 ,11 ,12 ,13 ,14 ,15 ,16
	//이 인덱스들을 n = 4로 나누면
	//0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3
	//입니다. 
	//그리고 처음의 인덱스들을 4로 나눈 나머지를 구하면
	//0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3
	//이 됩니다.
	//이것을 2차원 배열의 주소값에 각각 넣습니다.
	//그러면 1~4까지의 숫자는 [0][0] ~ [0][3] 에 저장이 되고
	//5~8까지의 숫자는 [1][0] ~ [1][3] 에 저장이 되는 방식입니다.
	//
	//이제 오류가 없다면 [4] 위치에 값 1개를 넣을수 있는 메모리를 주고, 그 위치에 n 값을 저장합니다.
	//
	//이로써 반환되는 배열은 입력된 인풋값 4 x n 개와, n의 값을 가지고 있습니다.
	data[4] = malloc(sizeof(int));
	data[4][0] = n;
	return (data);
}
